### MessageQueue

#### 简介

+ 我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中重要 的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。比如生产者发送消息1,2,3...对于消费者就会按照1,2,3...的顺序来消费。

#### 应用场景

+ 应用耦合：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；
+ 异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间； 
+ 限流削峰：广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；
+ 消息驱动的系统：系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理

#### 消息队列的两种模式

+ 点对点模式和发布订阅模式

  + 点对点
    + 点对点模式包括三个角色
      + 消息队列
      + 发送者 (生产者)
      + 接收者（消费者）
    + 点对点模式特点：
      + 每个消息只有一个消费者，一旦被消费，消息就不再在消息队列中； 
      + 发送者和接收者间没有依赖性，发送者发送消息之后，不管有没有接收者在运行，都不会影响到发送者下次发送消息；
      + 接收者在成功接收消息之后需向队列应答成功，以便消息队列删除当前接收的消息；
  + 发布订阅模式
    + 发布/订阅模式下包括三个角色：
      + 角色主题（Topic）
      + 发布者(Publisher) 
      + 订阅者(Subscriber)
    + 发布订阅模式特点
      + 消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被多个 订阅者消费。
      + 每个消息可以有多个订阅者；
      + 发布者和订阅者之间有时间上的依赖性
      + 为了消费消息，订阅者必须保持在线运行。

  #### 消息队列的实现机制

  + JMS

    + JMS（JAVA Message Service，Java消息服务）是一个Java平台中关于面向消息中间件的API，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息 是一个消息服务的标准或者说是规范，是 Java 平台上有关面向消息中间件的技术规范 便于消息系统中的 Java 应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。 JMS 消息机制主要分为两种模型：PTP 模型和 Pub/Sub 模型。 实现产品：Apache ActiveMQ

  + AMQP

    + AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开 放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条 件的限制。Erlang中的实现有RabbitMQ等。

  + JMS VS AMQP

    |              | JMS                                                          | AMQP                                                         |
    | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 定义         | Java API                                                     | Wire-protocol                                                |
    | 跨语言       | n                                                            | y                                                            |
    | 跨平台       | n                                                            | y                                                            |
    | model        | 提供两种消息模型：（1）Peer-2- Peer（2）Pub/sub              | 提供了五种消息模型：（1）、direct exchange（2）、fanout exchange（3）、topic change（4）、headers exchange（5）、system exchange本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路 由机制上做了更详细的划分； |
    | 支持消息类型 | 多种消息类型：TextMessage、 MapMessage、BytesMessage、 StreamMessage、ObjectMessage、 Message （只有消息头和属性） | byte[]当实际应用时，有复杂的消息，可以将消息序列化后发送。   |
    | 综合         | JMS 定义了JAVA API层面的标准；在java 体系中，多个client均可以通过JMS进行交 互，不需要应用修改代码，但是其对跨平 台的支持较差； | AMQP定义了wire-level层的协议标准；天然具有跨平台、跨语言特性。 |

  #### 常见消息队列产品

  + RabbitMQ 

    + RabbitMQ 2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。 

  + ActiveMQ 

    + ActiveMQ是由Apache出品，ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。它非常快速，支持多种语言的客户端 和协议，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能

  + RocketMQ 

    + RocketMQ出自 阿里公司的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进，消息可靠性上比 Kafka 更 好。RocketMQ在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理等 

  + Kafka 

    + Apache Kafka是一个分布式消息发布订阅系统。它最初由LinkedIn公司基于独特的设计实现为一个分布式的提交日志系统( a distributed commit log)，之后成为Apache项目的一部分。Kafka系统快速、可扩展并且可持久化。它的分区特性，可复制和可容错都是其不错的特性。

  + 对比

    | 特性       | ActiveMQ                               | RabbitMQ                                     | RocketMQ             | Kafka                                                        |
    | ---------- | -------------------------------------- | -------------------------------------------- | -------------------- | ------------------------------------------------------------ |
    | 开发语言   | java                                   | erlang                                       | java                 | scala                                                        |
    | 单机吞吐量 | 万级                                   | 万级                                         | 10万级               | 10万级                                                       |
    | 时效性     | ms级                                   | us级                                         | ms级                 | ms级以内                                                     |
    | 可用性     | 高（主从架构）                         | 高（主从架构）                               | 非常高（分布式架构） | 非常高（分布式架构）                                         |
    | 功能特性   | 成熟产品，有较多文档，各种协议支持较好 | 基于erlang开发，并发能力很强，性能好，延时低 | mq功能完备扩展性佳   | 只支持主要的mq功能，消息查询，消息回溯功能缺失，在大数据领域应用较广 |

 #### 技术选型

+ 中小型软件公司: 建议选RabbitMQ.一方面，erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。正所谓，成也萧何，败也萧何！他的 弊端也在这里，虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢？所幸，RabbitMQ的社区十分活跃，可以解决 开发过程中遇到的bug，这点对于中小型公司来说十分重要。不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司， 数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里 放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。
+ 大型软件公司： 根据具体使用在rocketMq和kafka之间二选一。一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。针 对rocketMQ,大型软件公司也可以抽出人手对rocketMQ进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。至于kafka，根 据业务场景选择，如果有日志采集功能，肯定是首选kafka了。